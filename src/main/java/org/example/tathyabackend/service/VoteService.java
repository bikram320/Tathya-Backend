package org.example.tathyabackend.service;

import lombok.AllArgsConstructor;
import org.bson.types.ObjectId;
import org.example.tathyabackend.exception.InvalidNewsException;
import org.example.tathyabackend.exception.InvalidValueException;
import org.example.tathyabackend.model.Vote;
import org.example.tathyabackend.repository.NewsRepository;
import org.example.tathyabackend.repository.VoteRepository;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.mongodb.client.result.UpdateResult;

import java.util.Optional;
import java.util.Set;

@AllArgsConstructor
@Service
public class VoteService {

    private final VoteRepository voteRepository;
    private final MongoTemplate mongoTemplate;
    private final NewsRepository newsRepository;

    // whitelist allowed metrics (must match your News.metrics field names exactly)
    private static final Set<String> VALID_METRICS = Set.of(
            "depthOfReporting", "politicalBiasness", "credibility", "relevance"
    );

    @Transactional
    public String vote(String userId, String newsId, String metric, int newValue) {

        if (!newsRepository.existsById(newsId)) {
            throw new InvalidNewsException("news with " + newsId + " does not exist");
        }
        if (newValue != 1 && newValue != -1) {
            throw new InvalidValueException("value must be 1 or -1");
        }
        if (!VALID_METRICS.contains(metric)) {
            throw new IllegalArgumentException("invalid metric: " + metric);
        }

        Optional<Vote> existingOpt = voteRepository.findByUserIdAndNewsIdAndMetric(userId, newsId, metric);

        if (existingOpt.isEmpty()) {
            Vote v = new Vote();
            v.setUserId(userId);
            v.setNewsId(newsId);
            v.setMetric(metric);
            v.setValue(newValue);
            voteRepository.save(v);

            // apply explicit delta
            if (newValue == 1) applyMetricDelta(newsId, metric, +1, 0);
            else applyMetricDelta(newsId, metric, 0, +1);

            return "created";
        } else {
            Vote existing = existingOpt.get();
            if (existing.getValue() == newValue) {
                return "no_change";
            } else {
                int prev = existing.getValue(); // 1 or -1
                existing.setValue(newValue);
                voteRepository.save(existing);

                // flip counts explicitly
                if (prev == 1 && newValue == -1) {
                    // upvote -> downvote
                    applyMetricDelta(newsId, metric, -1, +1);
                } else if (prev == -1 && newValue == 1) {
                    // downvote -> upvote
                    applyMetricDelta(newsId, metric, +1, -1);
                } else {
                    // fallback (shouldn't run)
                    if (prev == 1) applyMetricDelta(newsId, metric, -1, 0);
                    else applyMetricDelta(newsId, metric, 0, -1);

                    if (newValue == 1) applyMetricDelta(newsId, metric, +1, 0);
                    else applyMetricDelta(newsId, metric, 0, +1);
                }
                return "updated";
            }
        }
    }

    public Integer getUserVoteValue(String userId, String newsId, String metric) {
        return voteRepository.findByUserIdAndNewsIdAndMetric(userId, newsId, metric)
                .map(Vote::getValue).orElse(null);
    }

    /**
     * Apply explicit deltas to metrics.<br>
     * upvoteDelta and downvoteDelta can be -1, 0, or +1 (or any integer).
     * This method attempts query with ObjectId first (if newsId is a hex), and
     * falls back to string id if ObjectId is invalid or not matched.
     */
    private void applyMetricDelta(String newsId, String metric, int upvoteDelta, int downvoteDelta) {
        if (upvoteDelta == 0 && downvoteDelta == 0) return;

        Update u = new Update();
        if (upvoteDelta != 0) u.inc("metrics." + metric + ".upvote", upvoteDelta);
        if (downvoteDelta != 0) u.inc("metrics." + metric + ".downvote", downvoteDelta);

        // Try ObjectId matching first (most common for autogenerated ids)
        boolean triedOid = false;
        if (looksLikeObjectId(newsId)) {
            triedOid = true;
            try {
                Query qOid = new Query(Criteria.where("_id").is(new ObjectId(newsId)));
                UpdateResult resOid = mongoTemplate.updateFirst(qOid, u, "news");
                logUpdateResult(newsId, metric, upvoteDelta, downvoteDelta, "_id as ObjectId", resOid);
                if (resOid.getMatchedCount() > 0) return; // success
            } catch (IllegalArgumentException ignored) {
                // fall through to try string id
            }
        }

        // Fallback: try string id
        Query qString = new Query(Criteria.where("_id").is(newsId));
        UpdateResult resStr = mongoTemplate.updateFirst(qString, u, "news");
        logUpdateResult(newsId, metric, upvoteDelta, downvoteDelta,
                triedOid ? "_id as String (fallback)" : "_id as String", resStr);

        // If matchedCount==0 here, the update did not find the doc â€” check id type/collection
    }

    private void logUpdateResult(String newsId, String metric, int up, int down, String mode, UpdateResult r) {
        System.out.println("[VoteService.adjust] newsId=" + newsId +
                " metric=" + metric +
                " upDelta=" + up + " downDelta=" + down +
                " mode=" + mode +
                " matched=" + r.getMatchedCount() + " modified=" + r.getModifiedCount());
    }

    private boolean looksLikeObjectId(String id) {
        // quick hex length check (24 hex chars)
        return id != null && id.length() == 24 && id.matches("^[0-9a-fA-F]{24}$");
    }
}
